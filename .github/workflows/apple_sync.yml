name: Sync Apple

on:
  repository_dispatch:
    types: [apple-metrics]

permissions:
  contents: write

jobs:
  write-apple-json:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Parse payload.data, write JSON, and update knowledge CSVs
        id: write
        shell: bash
        env:
          # Nested payload shape
          CLIENT_PAYLOAD_DATA: ${{ toJson(github.event.client_payload.data) }}
          # Optional back-compat
          CLIENT_PAYLOAD_RAW:  ${{ toJson(github.event.client_payload) }}
          # CSV paths
          ACTIVITY_CSV: knowledge/activity_log.csv
          CARDIO_CSV:   knowledge/cardio_log.csv
          RECOVERY_CSV: knowledge/recovery_log.csv
        run: |
          set -euo pipefail
          python - <<'PY'
          import os, json, csv, pathlib
          from datetime import date

          def load_json_env(name):
              raw = os.environ.get(name, "")
              if not raw:
                  return {}
              try:
                  return json.loads(raw)
              except json.JSONDecodeError:
                  return {}

          # ---- Ingest payload (prefer nested)
          data = load_json_env("CLIENT_PAYLOAD_DATA")
          if not data:
              raw = load_json_env("CLIENT_PAYLOAD_RAW")
              if isinstance(raw, dict) and "data" in raw and isinstance(raw["data"], dict):
                  data = raw["data"]
              else:
                  data = raw

          if not isinstance(data, dict) or not data:
              print("No payload received"); raise SystemExit(0)

          # ---- Helpers
          def ensure_csv(path: str, header: list[str]) -> None:
              p = pathlib.Path(path)
              p.parent.mkdir(parents=True, exist_ok=True)
              if not p.exists():
                  with p.open("w", newline="", encoding="utf-8") as f:
                      csv.writer(f).writerow(header)

          def clean_num(v, as_int=True):
              if v is None: return None
              if isinstance(v, (int, float)):
                  return int(v) if as_int else float(v)
              s = str(v).replace(",", "").strip()
              try:
                  return int(float(s)) if as_int else float(s)
              except Exception:
                  return None

          def clean_sleep(obj):
              if isinstance(obj, dict): return obj
              if isinstance(obj, str):
                  try:
                      maybe = json.loads(obj)
                      if isinstance(maybe, dict): return maybe
                  except Exception:
                      pass
              return {}

          # ---- Normalise inputs
          date_str = str(data.get("date") or date.today())
          tz = data.get("timezone", "Europe/London")
          src = data.get("source", "apple_shortcut")

          steps              = clean_num(data.get("steps"))
          ex_minutes         = clean_num(data.get("exercise_minutes"))
          cals_active        = clean_num(data.get("calories_active"))
          cals_resting       = clean_num(data.get("calories_resting"))
          cals_total         = clean_num(data.get("calories_total"))
          stand_minutes      = clean_num(data.get("stand_minutes"))
          distance_m         = clean_num(data.get("distance_m"))

          hr_min             = clean_num(data.get("hr_min"))
          hr_max             = clean_num(data.get("hr_max"))
          hr_avg             = clean_num(data.get("hr_avg"))
          hr_resting         = clean_num(data.get("hr_resting"))

          sleep_dict         = clean_sleep(data.get("sleep_minutes"))
          sleep_asleep       = clean_num(sleep_dict.get("asleep"))
          sleep_awake        = clean_num(sleep_dict.get("awake"))
          sleep_core         = clean_num(sleep_dict.get("core"))
          sleep_deep         = clean_num(sleep_dict.get("deep"))
          sleep_in_bed       = clean_num(sleep_dict.get("in_bed"))
          sleep_rem          = clean_num(sleep_dict.get("rem"))

          # ---- JSON artefacts under docs/apple
          days_dir = pathlib.Path("docs/apple/days"); days_dir.mkdir(parents=True, exist_ok=True)
          daily_path = pathlib.Path("docs/apple/daily.json")
          hist_p = pathlib.Path("docs/apple/history.json")

          out_json = {
            "source": src,
            "date": date_str,
            "timezone": tz,
            "steps": steps,
            "hr_min": hr_min,
            "hr_max": hr_max,
            "hr_avg": hr_avg,
            "hr_resting": hr_resting,
            "exercise_minutes": ex_minutes,
            "calories_active": cals_active,
            "calories_resting": cals_resting,
            "calories_total": cals_total,
            "stand_minutes": stand_minutes,
            "distance_m": distance_m,
            "sleep_minutes": {
              "asleep": sleep_asleep,
              "awake": sleep_awake,
              "core": sleep_core,
              "deep": sleep_deep,
              "in_bed": sleep_in_bed,
              "rem": sleep_rem
            },
          }

          (days_dir / f"{date_str}.json").write_text(json.dumps(out_json, indent=2), encoding="utf-8")
          daily_path.write_text(json.dumps(out_json, indent=2), encoding="utf-8")

          history=[]
          if hist_p.exists():
              try: history=json.loads(hist_p.read_text(encoding="utf-8"))
              except Exception: history=[]
          history=[h for h in history if h.get("date")!=date_str]
          history.append(out_json)
          history=sorted(history,key=lambda x:x.get("date",""),reverse=True)[:90]
          hist_p.write_text(json.dumps(history, indent=2), encoding="utf-8")

          # ---- knowledge CSVs
          act_csv = os.environ.get("ACTIVITY_CSV", "knowledge/activity_log.csv")
          car_csv = os.environ.get("CARDIO_CSV",   "knowledge/cardio_log.csv")
          rec_csv = os.environ.get("RECOVERY_CSV", "knowledge/recovery_log.csv")

          # Define headers
          act_hdr = ["date","steps","exercise_minutes","calories_active","calories_resting","calories_total","stand_minutes","distance_m","source"]
          car_hdr = ["date","hr_min","hr_max","hr_avg","hr_resting","source"]
          rec_hdr = ["date","sleep_asleep_min","sleep_awake_min","sleep_core_min","sleep_deep_min","sleep_in_bed_min","sleep_rem_min","source"]

          # Ensure CSVs exist
          ensure_csv(act_csv, act_hdr)
          ensure_csv(car_csv, car_hdr)
          ensure_csv(rec_csv, rec_hdr)

          # Upsert rows for this date
          def read_rows(path, key="date"):
              rows={}
              try:
                  with open(path,"r",newline="",encoding="utf-8") as f:
                      for r in csv.DictReader(f):
                          rows[r[key]] = r
              except FileNotFoundError:
                  pass
              return rows

          def write_rows(path, header, rows_map):
              with open(path,"w",newline="",encoding="utf-8") as f:
                  w=csv.DictWriter(f, fieldnames=header); w.writeheader()
                  for k in sorted(rows_map.keys()):
                      w.writerow({h: rows_map[k].get(h,"") for h in header})

          # Activity
          act_rows = read_rows(act_csv)
          act_rows[date_str] = {
            "date": date_str,
            "steps": "" if steps is None else steps,
            "exercise_minutes": "" if ex_minutes is None else ex_minutes,
            "calories_active": "" if cals_active is None else cals_active,
            "calories_resting": "" if cals_resting is None else cals_resting,
            "calories_total": "" if cals_total is None else cals_total,
            "stand_minutes": "" if stand_minutes is None else stand_minutes,
            "distance_m": "" if distance_m is None else distance_m,
            "source": src
          }
          write_rows(act_csv, act_hdr, act_rows)

          # Cardio
          car_rows = read_rows(car_csv)
          car_rows[date_str] = {
            "date": date_str,
            "hr_min": "" if hr_min is None else hr_min,
            "hr_max": "" if hr_max is None else hr_max,
            "hr_avg": "" if hr_avg is None else hr_avg,
            "hr_resting": "" if hr_resting is None else hr_resting,
            "source": src
          }
          write_rows(car_csv, car_hdr, car_rows)

          # Recovery
          rec_rows = read_rows(rec_csv)
          rec_rows[date_str] = {
            "date": date_str,
            "sleep_asleep_min": "" if sleep_asleep is None else sleep_asleep,
            "sleep_awake_min": "" if sleep_awake is None else sleep_awake,
            "sleep_core_min": "" if sleep_core is None else sleep_core,
            "sleep_deep_min": "" if sleep_deep is None else sleep_deep,
            "sleep_in_bed_min": "" if sleep_in_bed is None else sleep_in_bed,
            "sleep_rem_min": "" if sleep_rem is None else sleep_rem,
            "source": src
          }
          write_rows(rec_csv, rec_hdr, rec_rows)

          print(json.dumps({
            "date": date_str,
            "csvs": {
              "activity": act_csv,
              "cardio": car_csv,
              "recovery": rec_csv
            },
            "docs": "docs/apple"
          }))
          PY

      - name: Commit Apple JSON and CSVs
        run: |
          if [[ -n "$(git status --porcelain docs/apple knowledge/*.csv 2>/dev/null || true)" ]]; then
            git config user.name  "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add docs/apple knowledge/*.csv
            git commit -m "chore: apple metrics update, split knowledge into activity/cardio/recovery"
            git push
          else
            echo "No changes to commit."
          fi